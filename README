
SHIBUI
=========================================

Fairly basic hashmap implementation built on top of an async TCP server
featuring epoll, a toy project just for learning purpose.

The project is a minimal redis-like implementation with a text based protocol,
currently supports basic operations:

- SET key value
- GET key
- DEL key
- INC key
- DEC key
- SUB key
- UNSUB key
- PUB key value
- KEYS
- VALUES
- COUNT
- TAIL key number
- PREFSCAN key_prefix
- FUZZYSCAN pattern
- FLUSH
- QUIT/EXIT

All commands are case insensitive, so not strictly uppercase. Shibui can be used
as a basic message broker through commands PUB/SUB to pulish messages to
multiple subscriber, using a key as a topic.
Shibui server expect an optional arg to set an arbitrary host to listen on port
6373, otherwise localhost will be automatically set.
Actually there's no client console so it can be tested using a generic tcp
client like telnet or netcat.

Out of the common commands like SET, GET or COUNT who everyone probably knows
the behavior, TAIL key number is a command that allow a client to consume an
arbitrary number of chronologically sorted messages published to a specific key,
with number as the offset for the depletion. 0 means from the start of the
publication, increasing number discard the same quantity of messages starting
from the oldest going to younger. E.g:

topic_key
 - i am
 - a stream
 - of useless
 - messages

tail topic_key 0 -> i ama streamof uselessmessages
tail topic_key 2 -> of uselessmessages

All subsequent messages published to the key topic will be normally dispatched
like a normal SUB command.

Actually the keyspace is distributed across 1024 partitions based on consistent
hashing of the keys, this way should be simplier to eventually distribute data
across multiple nodes.

* BUILD

To build the source just run make. A shibui executable will be generated that
can be started to listen on localhost:6737, ready to receive commands from any
TCP client.

* CHANGELOG
=========================================

2016-08-25

- Added new command `TAIL key number`, consume all values published to a key and
  subscribe to it. Number is the offset of the depletion, with 0 meaning "from
  the very first" and incresing number discard subsequents messages.

- Fixed some bugs e refactored some code.

- Added new command `PREFSCAN key_prefix`, find all values associated to keys that
  matches the prefix specified by key_prefix.

2016-08-26

- Added new command `FUZZYSCAN pattern`, perform a search through the keyspace
  returning all values associated to keys that match a given pattern by fuzzy
  search.

- Added new command `UNSUB key` to stop receiving feeds from the key.

- Added new command `FLUSH' to delete all keys in the keyspace

- Fixed rehash_map code in order to update data history and the subscribers
  array as well when resizing the map.

- Added new commands `KEYS` and `VALUES` respectively return all keys and all
  values stored in the hashmap

- Added partitioning to keyspace distribution, this should simplify an aventual
  distribution across multiple nodes.

* TODO
=========================================

- Persistence on disk, maybe through logging
- CLI to send commands and format output
- Additional commands
- Distribution system (fairly hard)
